# trit_cpu_c++
Данный проект является эмулятором сбалансированного троичного процессора, который использует троичную систему счисления. 
Данная система счисления использует три символа: -1, 0 и 1, которые в данном проекте представлены классом "trit".

Класс "trit" (трит) реализован как перечисление (enum class) на основе типа int8_t. 
Доступные значения: trit::Minus (представляет -1), trit::Zero (представляет 0) и trit::Plus (представляет 1).

Класс "trype" (трайт) хранит по 3 трита и является аналогом байта в бинарной системе. 

Конструкторы:
```cpp
constexpr tryte() noexcept // созадет трайт со всеми тритами равными нулю
constexpr tryte(trit high, trit mid, trit low) noexcept // создает трайт с указанными тритами
```

Методы доступа:
```cpp
trit get(int index) const // возвращает трит по индексу (0 - старший, 1 - средний, 2 - младший)
void set(int index, trit t) // устанавливает трит по индексу (0 - старший, 1 - средний, 2 - младший)
```

Для отладки реализован метод toString(), который возвращает строковое представление трайта в виде "++-", где "+" - trit::Plus, "0" - trit::Zero, "-" - trit::Minus.

В ALU.h реализованы основные арифметическо логические операции над трайтами. 
Вы с ними не взаимодействуете напрямую, только через опкоды в CPU.h. 
Сейчас реализованы операции inc(), dec(), negate(), add(), sub(), а также логические операции logicalNot(), logicalAnd(), logicalOr(), logicalXor(), equals(), lessThan().

Реализовано в CPU.h только inc(), dec(), negate(), add(), sub().


memory.h реализует память процессора. Память может быть инициализирована "memory mem(int);" или "memory memory(int);". 

"memory mem(int);" является аналогом RAM. После "memory mem(int);" требуеться привязать память к процессору с помощью "cpu.attachmemory(&mem);". 

"memory memory(int);" является аналогом ROM. После "memory memory(int);" пишем команды, например "memory.set(0, Tryte(trit::Plus, trit::Plus, trit::Zero));", и в конце указываем в какой файл нужно сохранить "memory.saveToFile("Имя_файла.tcode");". 
Для загрузки команд из файла используем "mem.loadFromFile("Имя_файла.tcode");".

В обоих случаях int обозначает количество ячеек памяти. 1 ячейка = 1 команда.


CPU.h уже является связующим звеном между всеми компонентами процессора. 
В нем реализованы команды, которые вы можете использовать в своем коде. 
Для его работы требуется инициализация памяти "memory mem(int);", процессор "CPU cpu;", привязать память к процессору "cpu.attachmemory(&mem);" и запустить "cpu.run();".

Всего CPU.h поддерживает 27 регистров общего назначение (1 трайт), 8 регистров для символов (2 трайта), 1 регистр переполнения (1 трит) и регист счеткика команд (временно size_t) которые можно использовать в коде.

Из за ограничений С++ использование регистров вышло запутаным.
```cpp
registers[0] = tryte(trit::Plus, trit::Plus, trit::Plus);// регистр 0 со значением 13 (+++)
mem.set(0, tryte(trit::Plus, trit::Plus, trit::Zero)); // INC
mem.set(1, tryte(trit::Minus, trit::Minus, trit::Minus)); // Регистр 0, получаем 14 (1---)
```

Для вызова Регистр 0 используется "registers[0]", где 0 - номер регистра. 
Но для использования в командах нужно использовать "mem.set(1, tryte(trit::Minus, trit::Minus, trit::Minus));", где tryte(trit::Minus, trit::Minus, trit::Minus) - номер регистра. 
Внутри CPU.h происходит смешение номеров регистров на -13, потому что нельзя вызывать регистры registers[-13].


Можно еще использовать utils для обозначения номера регистра и его значения
```cpp
registers[0] = utils::fromInt(13);// регистр 0 со значением 13 (+++)
mem.set(0, tryte(trit::Plus, trit::Plus, trit::Zero)); // INC
mem.set(1, utils::fromInt(0-13)); // Регистр 0, получаем 14 (1---)
```

Регистр для символов имеет другую структуру, он состоит из двух трайтов, поэтому может принимать значения от 0 до 728.
Сторого говоря сам регистр вы напрямую не вызываете, а используете его в командах ввода (i_trit6()) и вывода (o_trit6()).
```cpp
i_trit6(0, 221); // symreg 0 со символом 221
i_trit6(1, 219); // symreg 1 со символом 219
i_trit6(2, 209); // symreg 2 со символом 209
i_trit6(3, 10); // symreg 3 со символом 10

std::cout << TRIT6[o_trit6(0)] << TRIT6[o_trit6(1)] << TRIT6[o_trit6(2)] << TRIT6[o_trit6(3)]; // выводим символы из регистров symreg 0-3
```

TRIT6 является массивом символов основаным на UTF-8, из которого вы и берете символы для symreg.
```cpp
{
    //управляющие символы (0-32)
    "\0", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06",
    "\a", "\b", "\t", "\n", "\v", "\f", "\r",
    "\x0E", "\x0F", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x17",
    "\x18", "\x19", "\x1A", "\x1B", "\x1C", "\x1D", "\x1E", "\x1F",
    "\x7F",

    "", "", "", "", "", "", "",

    // знаки препинания и специальные символы (40-72)
    " ", "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~",

    "", "", "", "", "", "", "",

    // пунктуация и символы из Unicode (80-114)
    "¡", "¿", "«", "»", "‹", "›", "„", "“", "”", "‘", "’", "‚", "…", "‐", "‑", "‒", "–", "—", "―", "·", "•", "‣", "◦", "§", "¶", "©", "®", "™", "°", "‰", "′", "″", "※", "†", "‡",

    "", "", "", "", "",

    // цифры (120-129)
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",

    "", "", "", "", "", "", "", "", "", "", // +10

    // латинские буквы (140-191)
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", // 140-165
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", // 166-191


    "", "", "", "", "", "", "", "",

    // кириллические буквы (200-301)
    "А", "Б", "В", "Г", "Д", "Е", "Ж", "З", "И", "Й", "К", "Л", "М", "Н", "О", "П", "Р", "С", "Т", "У", "Ф", "Х", "Ц", "Ч", "Ш", "Щ", "Ъ", "Ы", "Ь", "Э", "Ю", "Я", // 200-231
    "а", "б", "в", "г", "д", "е", "ж", "з", "и", "й", "к", "л", "м", "н", "о", "п", "р", "с", "т", "у", "ф", "х", "ц", "ч", "ш", "щ", "ъ", "ы", "ь", "э", "ю", "я", // 232-263
    "Ё", "Є", "Ї", "І", "Ј", "Љ", "Њ", "Ћ", "Ќ", "Ў", "Џ", "Ђ", "Ѓ", "Ѐ", "Ѝ", // 264-278
    "ё", "є", "ї", "і", "ј", "љ", "њ", "ћ", "ќ", "ў", "џ", "ђ", "ѓ", "ѐ", "ѝ", // 279-293
    "Ѡ", "ѡ", "Ѣ", "ѣ", "Ѳ", "ѳ", "Ѵ", "ѵ", // 294-301  

    "", "", "", "", "", "", "", "", "", "", // +10
    "", "", "", "", "", "", "", "",

    // греческие буквы (320-367)
    "Α", "Β", "Γ", "Δ", "Ε", "Ζ", "Η", "Θ", "Ι", "Κ", "Λ", "Μ", "Ν", "Ξ", "Ο", "Π", "Ρ", "Σ", "Τ", "Υ", "Φ", "Χ", "Ψ", "Ω", // 320-343
    "α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ", "λ", "μ", "ν", "ξ", "ο", "π", "ρ", "σ", "τ", "υ", "φ", "χ", "ψ", "ω", // 344-367 

    "", "", "", "", "", "", "", "", "", "", // +10
    "", "",

    // математические символы (380-474)
    "⁰", "¹", "²", "³", "⁴", "⁵", "⁶", "⁷", "⁸", "⁹", "⁺", "⁻", "⁼", "⁽", "⁾", "ⁿ", // верхние индексы (380-395)
    "₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉", "₊", "₋", "₌", "₍", "₎", // нижние индексы (396-410)
    "±", "∓", "×", "÷", "∙", "•", "∗", "∶", "∝", "∞", "∑", "∏", "√", "∛", "∜", // арифметические операторы (411-425)
    "≠", "≤", "≥", "≡", "≈", "≅", "≃", "∼", "∽", "∝", // сравнения и отношения (426-435)
    "∈", "∉", "∋", "∌", "⊂", "⊃", "⊆", "⊇", "∪", "∩", "∅", "¬", "∧", "∨", "⊻", "⊼", "⊽", "⊤", // множества и логика (436-453)
    "∇", "∂", "∆", "∫", "∬", "∭", "∮", // дифференциалы и интегралы (454-460)
    "∴", "∵", "∟", "∠", "⊥", "∥", "°", "′", "″", "ℓ", "ℏ", "π", "ℇ", "φ", // прочее (461-474)

    "", "", "", "", "", "", "", "", "", "", // +10
    "", "", "", "", "",

    // валютные символы (490-509)
    "₽", "€", "$", "£", "¥", "¢", "₹", "₩", "₴", "₦", "₱", "₮", "₡", "₲", "₸", "₭", "؋", "₼", "₪", "¤",

    "", "", "", "", "", "", "", "", "", "", // +10

    // стрелки (520-535)
    "↑", "↓", "←", "→", "↔", "↕", "↖", "↗", "↘", "↙", "⇐", "⇒", "⇑", "⇓", "⇔", "⇕",

    "", "", "", "", "", "", "", "", "", "", // +10
    "", "", "", "",

    // циклы и управляющие символы (550-561)
    "⟳", "⟲", "↻", "↺", "⤴", "⤵", "⏮", "⏭", "⏯", "⏸", "⏹", "⏺",

    "", "", "", "", "", "", "", "",

    // научные доп. (570-572)
    "°C", "°F", "℉",

    "", "", "", "", "", "", "", "", "", "", // +10
    "", "", "", "", "", "", "",

    // Псевдографика (590-684)
    "─", "━", "│", "┃", "┌", "┐", "└", "┘", "├", "┤", "┬", "┴", "┼", "═", "║", "╔", "╗", "╚", "╝", "╠", "╣", "╦", "╩", "╬", // рамки и линии (590-613)
    "■", "□", "▲", "△", "▼", "▽", "●", "○", "◆", "◇", "◊", "◼", "◻", // геометрические фигуры (614-626)
    "✓", "✗", "✦", "★", "☆", "✧", "✶", "✿", // спец. пиктограммы (617-634)
    "☀", "☁", "☂", "☃", "☠", "⚠", "⚡", "⚙", // символы погоды и предупреждений (635-642)
    "ⓐ", "ⓑ", "ⓩ", "①", "②", "⑩", "🅰", "🅱", "🅾", "🆎", "🆑", // символы в кружках / закодированные (643-653)
    "░", "▒", "▓", "█", // тонирование (654-657)
    "▁", "▂", "▃", "▄", "▅", "▆", "▇", // горизонтальные блоки (658-664)
    "▉", "▊", "▋", "▌", "▍", "▎", "▏", "▐", "▔", "▕",  // вертикальные блоки (665-674)
    "▖", "▗", "▘", "▙", "▚", "▛", "▜", "▝", "▞", "▟", // комбинированные блоки (675-684)

    "", "", "", "", "",

    // шахматы (690-701)
    "♔", "♕", "♖", "♗", "♘", "♙", // 690-695
    "♚", "♛", "♜", "♝", "♞", "♟", // 696-701

    "", "", "", "", "", "", "", "",

    // карты (710-713)
    "♠", "♣", "♥", "♦",

    "", "", "", "", "", "",

    // кости (d6) (720-725)
    "⚀", "⚁", "⚂", "⚃", "⚄", "⚅",

    // резевр (726-728)
    "", "", ""
};
```

Регистр переполнения (EX) используется для хранения состояния переполнения арифметических операций и используется только для вывода.
В дальнейшем планируется добавить регистр для математических операций, который будет хранить результат операций в 2-х трайтах, как сейчас работает symreg.

Для просмотра состояния регистра EX используется 
```cpp
std::cout << static_cast<int>(EX) << std::endl;
```
Полькольку EX является тритом, а не трайтом, то его значение может быть -1, 0 или 1, а не +0-, и на него неработает метод toString().

Регистр счетчика команд (pc) используется для отслеживания текущей команды, которая выполняется процессором.

Рекомендую все же вручную выставлять данный регистр, чтобы избежать путаницы при использовании некоторых команд:
```cpp
mem.set(0, ...);
mem.set(1, ...);
mem.set(2, ...);
mem.set(3, ...);
mem.set(4, ...);
```
Но для удобства можно использовать так:
```cpp
int pc = 0; // счетчик команд
mem.set(pc++, ...);
mem.set(pc++, ...);
mem.set(pc++, ...);
mem.set(pc++, ...);
mem.set(pc++, ...);
```


Инструкции, которые можно использовать в коде:

| код | Инструкция | Назначение                           |
| --  | ---------- | ------------------------------------ |
| 000 | NOP        | Пустая операция                      |
| 00+ | HLT        | Остановка программы                  |
| +0+ | LOAD       | Загрузка значения в регистр          |
| +0- | STORE      | Запись значения регистра в память    |
| -0+ | LOADM      | Загрузка из памяти в регистр         |
| -0- | STOREM     | Запись в память из регистра          |
| ++0 | INC        | Увеличение регистра на 1             |
| --0 | DEC        | Уменьшение регистра на 1             |
| 0++ | ADD        | Сложение                             |
| 0-- | SUB        | Вычитание                            |
| 0-+ | JMP        | Безусловный переход                  |
| --- | NOT        | Побитовое отрицание                  |


NOP и HALT аргументов не имеет. 
INC и DEC используют регистр, который находится в памяти на следующем шаге и сохраняют результат EX + регистр.
ADD и SUB используют 2 регистра, который находится в памяти на следующем шаге и сохраняют результат EX + первый регистр.
NOT использует регистр, который находится в памяти на следующем шаге и сохраняет результат в регистр.
JMP следующим шагом должен быть аргумент, который указывает на какой шаг перейти.
LOAD используют регистр, после укавыется шаг (pc) в котором находится значение для загрузки в регистр.
STORE используют регистр-источник, после укавыется шаг (pc) в который нужно записать значение из регистра.
LOADM используют 2 регистра. Первый регистр получает значение из памяти, второй регистр указывает на адрес (pc) в памяти.
STOREM использует 2 регистра. Первый регистр-источник, второй регистр указывает на адрес (pc) в памяти в который нужно записать значение из регистра.


Utils.h содержит функции для работы преобразование fromInt и toInt. 


Пример использования:
```cpp
// инициализация процессора
memory mem(12); // создаем память с 12 ячейками
CPU cpu;
cpu.attachmemory(&mem);

registers[0] = tryte(trit::Zero, trit::Plus, trit::Plus);// регистр 0 со значением 4 (0++)
registers[1] = tryte(trit::Zero, trit::Plus, trit::Zero); // регистр 1 со значением 3 (0+0)

// пишем команды в память. Сначало счетчик команды, потом команда или аргумент
mem.set(0, tryte(trit::Plus, trit::Plus, trit::Zero)); // INC
mem.set(1, tryte(trit::Minus, trit::Minus, trit::Minus)); // регистр 0, получаем 5 (0+--)

mem.set(2, tryte(trit::Minus, trit::Minus, trit::Zero)); // DEC
mem.set(3, tryte(trit::Minus, trit::Minus, trit::Zero)); // регистр 1, получаем 2 (00+-)

mem.set(4, tryte(trit::Zero, trit::Plus, trit::Plus)); // ADD
mem.set(5, tryte(trit::Minus, trit::Minus, trit::Minus)); // регистр 0, получаем 7 (0+-+)
mem.set(6, tryte(trit::Minus, trit::Minus, trit::Zero)); // регистр 1

mem.set(7, tryte(trit::Plus, trit::Zero, trit::Plus)); // LOAD
mem.set(8, tryte(trit::Minus, trit::Minus, trit::Zero)); // регистр 1, получаем 1 (00+) 
mem.set(9, utils::fromInt(10)); // адрес памяти, он же регистр pc, можно использовать tryte(trit::Plus, trit::Zero, trit::Plus)

mem.set(10, tryte(trit::Zero, trit::Zero, trit::Plus)); // HALT, останавливаем процессор обязательно

// запускаем процессор
cpu.run();

i_trit6(0, 157); // symreg 0 со символом 157 (R)
i_trit6(1, 120); // symreg 1 со символом 120 (0)
i_trit6(2, 121); // symreg 2 со символом 121 (1)
i_trit6(3, 40); // symreg 3 со символом 40 ( )
i_trit6(4, 59); // symreg 4 со символом 59 (=)

std::cout << TRIT6[o_trit6(0)] << TRIT6[o_trit6(1)] << TRIT6[o_trit6(3)] << TRIT6[o_trit6(4)] << TRIT6[o_trit6(3)] // выводит "R0 = " в консоль
    << registers[0].toString() << std::endl; // Выводим R0 для отладки
std::cout << TRIT6[o_trit6(0)] << TRIT6[o_trit6(2)] << TRIT6[o_trit6(3)] << TRIT6[o_trit6(4)] << TRIT6[o_trit6(3)] // выводит "R1 = " в консоль
    << registers[1].toString() << std::endl; // Выводим R1 для отладки
```


!!!ВАЖНО!!!

Считать номера регистров